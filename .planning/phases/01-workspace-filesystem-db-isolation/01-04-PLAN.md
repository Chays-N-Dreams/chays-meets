---
phase: 01-workspace-filesystem-db-isolation
plan: 04
type: execute
wave: 4
depends_on: ["01-03"]
files_modified:
  - frontend/src-tauri/src/workspace/migration.rs
  - frontend/src-tauri/src/workspace/mod.rs
  - frontend/src-tauri/src/database/setup.rs
autonomous: false

must_haves:
  truths:
    - "Existing meetings, transcripts, and summaries from meeting_minutes.sqlite are accessible in the Default workspace after migration"
    - "API keys and settings from the old database are accessible via global.sqlite after migration"
    - "Original database is backed up before any migration operations"
    - "Migration only runs once (detected by presence of existing DB + absence of workspaces)"
    - "Zero data loss: meeting count in Default workspace matches original DB"
    - "Audio file folder_path values are preserved in migrated meeting records and accessible from the Default workspace"
  artifacts:
    - path: "frontend/src-tauri/src/workspace/migration.rs"
      provides: "migrate_existing_database_to_workspace() function with audio path verification"
      contains: "migrate_existing"
    - path: "frontend/src-tauri/src/database/setup.rs"
      provides: "Migration invocation replacing the placeholder from Plan 03"
      contains: "migrate_existing"
  key_links:
    - from: "frontend/src-tauri/src/workspace/migration.rs"
      to: "frontend/src-tauri/src/workspace/manager.rs"
      via: "uses WorkspaceManager to create workspace and switch to it"
      pattern: "WorkspaceManager"
    - from: "frontend/src-tauri/src/database/setup.rs"
      to: "frontend/src-tauri/src/workspace/migration.rs"
      via: "calls migration when existing DB detected with no workspaces (replaces Plan 03 placeholder)"
      pattern: "migration::"
---

<objective>
Implement the migration path from the single meeting_minutes.sqlite database to the workspace architecture, ensuring zero data loss for existing users upgrading to v0.3.0.

Purpose: Users who have been using Meetily have all their meetings, transcripts, summaries, and settings in a single `meeting_minutes.sqlite` file. This plan creates a migration that backs up the original, creates a Default workspace, copies meeting data into it, extracts settings into global.sqlite, and verifies data integrity -- including audio file accessibility.

Output: A migration module that runs automatically on first launch after upgrade, with backup safety, data verification, and audio path handling.
</objective>

<execution_context>
@/Users/chaysenrathert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chaysenrathert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-CONTEXT.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-RESEARCH.md

# Prior plan outputs
@.planning/phases/01-workspace-filesystem-db-isolation/01-01-SUMMARY.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-02-SUMMARY.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-03-SUMMARY.md

# Key source files
@frontend/src-tauri/src/workspace/manager.rs
@frontend/src-tauri/src/database/setup.rs
@frontend/src-tauri/src/database/manager.rs
@frontend/src-tauri/migrations/20250916100000_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement existing database migration to workspace architecture</name>
  <files>
    frontend/src-tauri/src/workspace/migration.rs
    frontend/src-tauri/src/workspace/mod.rs
    frontend/src-tauri/src/database/setup.rs
  </files>
  <action>
**Part A: Create `workspace/migration.rs`**

Create a migration module with the main migration function:

```rust
pub async fn migrate_existing_database_to_workspace(
    workspace_mgr: &WorkspaceManager,
    existing_db_path: &Path,
) -> Result<String, String>
```

This function executes the following steps in this exact order. Do NOT reorder or interleave these steps:

**Step 1: Backup the original database**
- Copy `existing_db_path` to `{existing_db_path}.pre-workspace-backup`
- Also copy any `.wal` and `.shm` files if they exist (same naming pattern with `.pre-workspace-backup` suffix)
- Log: `"Backed up existing database to {backup_path}"`

**Step 2: Checkpoint existing DB WAL**
- Open a temporary SqlitePool to the existing DB (read-only connection options if possible, otherwise normal connect)
- Execute `PRAGMA wal_checkpoint(TRUNCATE)` to flush any pending WAL changes into the main DB file
- Close this temporary pool

**Step 3: Create Default workspace**
- Call `workspace_mgr.create_workspace("Default".to_string()).await`
- This creates the directory structure and updates the registry
- Store the returned workspace UUID as `default_id`

**Step 4: Copy existing DB to workspace path**
- Compute workspace DB path: `{workspace_mgr.workspaces_root()}/{default_id}/db.sqlite`
- Use `std::fs::copy(existing_db_path, &ws_db_path)` to copy the whole file
- This copy contains ALL tables (both workspace and global data) -- we will clean it in Step 6

**Step 5: Extract settings from the ORIGINAL database into global DB**
- Open a temporary pool to the ORIGINAL `existing_db_path` (NOT the workspace copy)
- Read all rows from `settings` table
- Read all rows from `transcript_settings` table
- Read all rows from `licensing` table (if exists -- use `SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='licensing'` to check)
- Read all rows from `custom_openai_config` table (if exists -- same check)
- Insert these rows into the global DB via `workspace_mgr.global_pool()` using `INSERT OR REPLACE`
- Use `sqlx::Row` trait with `row.try_get::<String, _>("column_name")` for dynamic column access, or use the ATTACH DATABASE approach:
  ```sql
  -- Alternative: If schemas match exactly, this is simpler
  ATTACH DATABASE '{global_db_path}' AS global_db;
  INSERT OR REPLACE INTO global_db.settings SELECT * FROM settings;
  INSERT OR REPLACE INTO global_db.transcript_settings SELECT * FROM transcript_settings;
  -- etc.
  DETACH DATABASE global_db;
  ```
  Choose whichever approach compiles and works. The ATTACH approach is simpler but requires schema parity. The row-by-row approach is safer.
- Log row counts: `"Migrated {N} settings rows, {M} transcript_settings rows"`
- Close the temporary pool to the original DB

**Step 6: Clean the workspace DB copy**
- Open a temporary pool to the workspace DB copy at `ws_db_path`
- Drop global-only tables that don't belong in workspace DB:
  ```sql
  DROP TABLE IF EXISTS settings;
  DROP TABLE IF EXISTS transcript_settings;
  DROP TABLE IF EXISTS licensing;
  DROP TABLE IF EXISTS custom_openai_config;
  ```
- Drop the `_sqlx_migrations` table to allow fresh workspace migrations to run:
  ```sql
  DROP TABLE IF EXISTS _sqlx_migrations;
  ```
- Close the temporary pool

**Step 7: Verify audio file accessibility**
- Open a temporary pool to the workspace DB copy
- Query: `SELECT id, folder_path FROM meetings WHERE folder_path IS NOT NULL AND folder_path != ''`
- For each meeting with a folder_path:
  - Check if the path exists on disk using `std::path::Path::new(&folder_path).exists()`
  - Count accessible vs inaccessible paths
- Log: `"Audio paths verified: {accessible}/{total} meeting audio folders are accessible"`
- If any paths are inaccessible, log a WARNING: `"Warning: {count} meeting(s) have audio paths that cannot be found. Audio files remain in their original locations and were not moved during migration. If you moved or deleted audio files, those recordings may be unavailable."`
- Do NOT fail the migration for inaccessible audio paths -- this is informational only
- Audio files are NOT moved or copied: migrated meetings keep their original `folder_path` values pointing to wherever the user saved recordings (typically Downloads or user-selected locations). Only NEW recordings made after migration will go into the workspace's `audio/` folder.
- Close the temporary pool

**Step 8: Switch to Default workspace**
- Call `workspace_mgr.switch_workspace(&default_id).await`
- This opens the workspace DB pool and runs workspace migrations against it

**Step 9: Verify migration data integrity**
- Using the now-active workspace pool (`workspace_mgr.active_pool().await?`):
  - Count meetings: `SELECT COUNT(*) FROM meetings`
- Reopen the original DB temporarily:
  - Count meetings there: `SELECT COUNT(*) FROM meetings`
- Compare counts
- Log: `"Migration verification: {original_count} meetings in original, {workspace_count} in Default workspace"`
- If counts don't match, log a WARNING (don't fail -- user can restore from backup)
- Return the `default_id` string

**Part B: Update `workspace/mod.rs`**
Add `pub mod migration;` to the module declarations.

**Part C: Replace migration placeholder in `database/setup.rs`**

In the `initialize_workspace_manager()` function, find the migration placeholder left by Plan 03 (Case A):

```rust
// MIGRATION HOOK: Plan 04 will replace this with actual migration call.
// For now, create an empty Default workspace so the app is usable during development.
let default_id = workspace_mgr.create_workspace("Default".to_string()).await?;
workspace_mgr.switch_workspace(&default_id).await?;
log::warn!("Migration placeholder: created empty Default workspace. Existing data not yet migrated.");
```

Replace with:

```rust
log::info!("Existing database found with no workspaces. Starting migration...");
match crate::workspace::migration::migrate_existing_database_to_workspace(
    &workspace_mgr,
    &existing_db,
).await {
    Ok(default_id) => {
        log::info!("Migration complete. Default workspace created: {}", default_id);
    }
    Err(e) => {
        log::error!("Migration failed: {}. Creating empty Default workspace as fallback.", e);
        // Fallback: create empty workspace so the app is still usable
        let fallback_id = workspace_mgr.create_workspace("Default".to_string()).await
            .map_err(|e| format!("Failed to create fallback workspace: {}", e))?;
        workspace_mgr.switch_workspace(&fallback_id).await
            .map_err(|e| format!("Failed to switch to fallback workspace: {}", e))?;
    }
}
```

**Sequencing clarification (for the executor):**
The init/migration flow in `database/setup.rs` is now:
1. `WorkspaceManager::init()` -- creates workspaces root, global.sqlite, loads registry. Returns with NO active workspace.
2. Check for existing `meeting_minutes.sqlite` AND empty registry -> if yes, call `migrate_existing_database_to_workspace()` which creates the Default workspace, populates it, and switches to it.
3. If migration not needed: existing workspace logic (Cases B/C/D from Plan 03) handles workspace selection.
4. Return WorkspaceManager with an active workspace.

This means migration runs AFTER init() but BEFORE any Default workspace auto-creation. The migration function itself creates the Default workspace as part of its process.
  </action>
  <verify>
1. `cargo check --manifest-path frontend/src-tauri/Cargo.toml` passes with zero errors.
2. Verify migration.rs exists with `migrate_existing_database_to_workspace()` function containing all 9 steps.
3. Verify database/setup.rs calls migration when existing DB is detected (the placeholder is replaced).
4. Verify migration.rs includes audio folder_path verification (Step 7) with warning logging for inaccessible paths.
5. Verify the step order in migration.rs: Backup -> Checkpoint -> Create workspace -> Copy DB -> Extract settings -> Clean workspace copy -> Verify audio -> Switch -> Verify data.
  </verify>
  <done>
Migration module exists and is integrated into app startup. When existing meeting_minutes.sqlite is detected with no workspaces: (1) original is backed up with .wal/.shm files, (2) WAL is checkpointed, (3) Default workspace created, (4) DB copied to workspace, (5) settings extracted to global DB, (6) workspace copy cleaned of global tables, (7) audio folder_path values verified with warnings for inaccessible paths, (8) workspace switched and migrations run, (9) meeting count verified. Audio files remain in original locations; migrated meetings keep their folder_path values.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete workspace filesystem and database isolation system:
- Workspace types and filesystem operations (Plan 01)
- WorkspaceManager with pool lifecycle management (Plan 02)
- All 24+ command handlers rewired from AppState to WorkspaceManager (Plan 03)
- Existing data migration to Default workspace with audio path verification (Plan 04)

The app should now start up, detect existing data, migrate it to a Default workspace, and function normally with all meetings accessible. Audio files remain in their original locations -- the migration preserves folder_path references without moving files.
  </what-built>
  <how-to-verify>
1. Run `cargo check --manifest-path frontend/src-tauri/Cargo.toml` -- should pass with zero errors
2. Run `./clean_run.sh` from the `frontend/` directory to launch the app
3. Verify the app starts without errors in the terminal log
4. Check terminal output for: "WorkspaceManager initialized", migration-related log messages
5. If you had existing meetings: verify they appear in the meeting list (now in Default workspace)
6. If fresh install: verify the app starts and shows empty meeting list (Default workspace created)
7. Check the filesystem: `ls ~/Library/Application\ Support/Meetily/workspaces/` should show:
   - `workspaces.json` (registry file)
   - `global.sqlite` (global settings DB)
   - A UUID-named directory containing: `manifest.json`, `db.sqlite`, `audio/`, `notes/`, `config.json`
8. If migration ran: verify `meeting_minutes.sqlite.pre-workspace-backup` exists in app data dir
9. If migration ran: check terminal for audio path verification logs (e.g., "Audio paths verified: X/Y meeting audio folders are accessible")
10. Try recording a short meeting -- should work normally (recording goes through active workspace pool)
11. Check that settings are preserved (LLM provider, API keys still configured)
  </how-to-verify>
  <resume-signal>Type "approved" if everything works, or describe any issues you see</resume-signal>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path frontend/src-tauri/Cargo.toml` passes
2. Migration module compiles and is integrated into startup
3. Backup is created before any destructive operations (Step 1 happens first)
4. Settings extraction (Step 5) happens before workspace copy cleanup (Step 6)
5. Audio folder_path values are preserved and verified with user-facing warnings for missing paths
6. Meeting count verification logged during migration
7. Fallback path exists if migration fails (empty Default workspace)
8. App starts, migrates, and functions normally
</verification>

<success_criteria>
- Existing meetings survive upgrade in Default workspace (zero data loss verified by meeting count comparison)
- API keys and settings accessible via global DB after migration
- Original database backed up at `meeting_minutes.sqlite.pre-workspace-backup` (plus .wal/.shm if present)
- Migration is idempotent (if workspaces already exist, migration is skipped)
- Audio folder_path values preserved in migrated meeting records, not moved or modified
- Warning logged for any audio paths that cannot be found on disk
- Migration step order is unambiguous: Backup -> Checkpoint -> Create -> Copy -> Extract settings -> Clean copy -> Verify audio -> Switch -> Verify data
- App is fully functional after migration: can view meetings, start recordings, access settings
- Workspace directory structure is clean and browsable on disk
</success_criteria>

<output>
After completion, create `.planning/phases/01-workspace-filesystem-db-isolation/01-04-SUMMARY.md`
</output>
