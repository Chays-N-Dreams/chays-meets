---
phase: 01-workspace-filesystem-db-isolation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - frontend/src-tauri/src/workspace/manager.rs
  - frontend/src-tauri/src/workspace/mod.rs
autonomous: true

must_haves:
  truths:
    - "WorkspaceManager can open a workspace's SQLite pool and provide it via active_pool()"
    - "WorkspaceManager can switch workspaces by closing the current pool and opening a new one"
    - "WorkspaceManager provides a global_pool() that is always available for settings queries"
    - "WorkspaceManager can create a new workspace (filesystem + registry update)"
    - "Only one workspace pool is open at any time"
  artifacts:
    - path: "frontend/src-tauri/src/workspace/manager.rs"
      provides: "WorkspaceManager struct with active_pool, global_pool, switch_workspace, create_workspace, init"
      contains: "pub struct WorkspaceManager"
    - path: "frontend/src-tauri/src/workspace/mod.rs"
      provides: "Re-exports manager module"
      contains: "pub mod manager"
  key_links:
    - from: "frontend/src-tauri/src/workspace/manager.rs"
      to: "frontend/src-tauri/src/workspace/filesystem.rs"
      via: "uses create_workspace_dir, write_manifest, save_registry, load_registry"
      pattern: "filesystem::"
    - from: "frontend/src-tauri/src/workspace/manager.rs"
      to: "frontend/src-tauri/src/workspace/types.rs"
      via: "uses WorkspaceManifest, WorkspaceRegistry, WorkspaceEntry"
      pattern: "types::"
    - from: "frontend/src-tauri/src/workspace/manager.rs"
      to: "frontend/src-tauri/src/database/manager.rs"
      via: "wraps DatabaseManager for active workspace pool"
      pattern: "DatabaseManager"
---

<objective>
Build the WorkspaceManager -- the central abstraction that manages workspace lifecycle, database pool switching, and global settings database.

Purpose: This struct replaces the old AppState as the Tauri managed state. It wraps the active workspace's DatabaseManager in `Arc<RwLock<Option<DatabaseManager>>>` so the pool can be swapped at runtime when switching workspaces. It also holds a persistent global DatabaseManager for settings/API keys that never switches.

Output: A fully functional WorkspaceManager struct with methods for workspace CRUD, pool access, and workspace switching. Not yet wired into Tauri (that's Plan 03).
</objective>

<execution_context>
@/Users/chaysenrathert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chaysenrathert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-CONTEXT.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-RESEARCH.md

# Prior plan output needed for types and filesystem
@.planning/phases/01-workspace-filesystem-db-isolation/01-01-SUMMARY.md

# Key source files
@frontend/src-tauri/src/database/manager.rs
@frontend/src-tauri/src/workspace/types.rs
@frontend/src-tauri/src/workspace/filesystem.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WorkspaceManager struct with pool lifecycle</name>
  <files>
    frontend/src-tauri/src/workspace/manager.rs
    frontend/src-tauri/src/workspace/mod.rs
  </files>
  <action>
Create `workspace/manager.rs` with the core WorkspaceManager struct.

**Struct definition:**
```rust
pub struct WorkspaceManager {
    /// Root directory for all workspaces (e.g., ~/Library/Application Support/Meetily/workspaces/)
    workspaces_root: PathBuf,
    /// Currently active workspace's DB pool (swappable via RwLock)
    active_db: Arc<RwLock<Option<DatabaseManager>>>,
    /// Global settings DB pool (always open, never switches)
    global_db: DatabaseManager,
    /// Currently active workspace UUID
    active_workspace_id: Arc<RwLock<Option<String>>>,
    /// Cached workspace registry (in-memory copy of workspaces.json)
    registry: Arc<RwLock<WorkspaceRegistry>>,
}
```

Use `tokio::sync::RwLock` (NOT `std::sync::RwLock`) since all accessors are async.

**Methods to implement:**

1. `pub async fn init(app_data_dir: PathBuf) -> Result<Self, String>`:
   - Compute workspaces_root as `{app_data_dir}/workspaces/`
   - Create workspaces_root directory if it doesn't exist
   - Initialize global.sqlite at `{workspaces_root}/global.sqlite`:
     - Create DatabaseManager for global DB by connecting to the SQLite file with `create_if_missing(true)`, WAL journal mode, foreign_keys enabled
     - NOTE: Cannot use `sqlx::migrate!("./migrations/global")` because the existing `sqlx::migrate!("./migrations")` macro is still present for backward compatibility. Instead, use `sqlx::Migrator::new()` with a runtime path OR manually execute the SQL from the global migration file. Choose the approach that compiles. If `sqlx::migrate!()` with a different path causes compile issues, use `sqlx::query()` to execute the CREATE TABLE statements directly (the global schema is simple enough for this).
   - Load registry from workspaces.json (or create empty if missing)
   - Set active_db to None, active_workspace_id to None
   - If registry has `last_active`, call `switch_workspace()` to restore last active workspace
   - Return the initialized WorkspaceManager

2. `pub async fn active_pool(&self) -> Result<SqlitePool, String>`:
   - Acquire read lock on active_db
   - If Some(db_manager), return `db_manager.pool().clone()`
   - If None, return error: "No active workspace. Please select or create a workspace."

3. `pub fn global_pool(&self) -> &SqlitePool`:
   - Return reference to global_db's pool (always available, no lock needed)
   - NOTE: This cannot be `&SqlitePool` if DatabaseManager is behind Arc. Evaluate if you need to clone the pool or if `global_db` can be a direct field. The existing `DatabaseManager::pool()` returns `&SqlitePool`. Since `global_db` is owned directly (not behind RwLock), this works.

4. `pub async fn switch_workspace(&self, workspace_id: &str) -> Result<(), String>`:
   - Close current pool if any: acquire write lock on active_db, take the Option value, call cleanup() on it
   - Resolve workspace path: `{workspaces_root}/{workspace_id}/`
   - Verify workspace directory exists and has manifest.json
   - Construct SQLite URL for `{workspace_dir}/db.sqlite`
   - Create new SqlitePool with: `create_if_missing(true)`, WAL journal mode, `foreign_keys(true)`, max_connections(5)
   - Run workspace migrations against the new pool. Same note as global migrations -- if `sqlx::migrate!("./migrations/workspace")` causes compile issues, execute CREATE TABLE SQL directly via `sqlx::query()`.
   - Update active_db with new DatabaseManager
   - Update active_workspace_id
   - Update registry's last_active field and save to disk
   - Log the switch: `log::info!("Switched to workspace: {}", workspace_id)`

5. `pub async fn create_workspace(&self, name: String) -> Result<String, String>`:
   - Generate UUID via `uuid::Uuid::new_v4().to_string()`
   - Call `filesystem::create_workspace_dir(&self.workspaces_root, &id)`
   - Create WorkspaceManifest with provided name, current timestamp, version 1, app_version from env!("CARGO_PKG_VERSION")
   - Call `filesystem::write_manifest()`
   - Call `filesystem::write_default_config()`
   - Update in-memory registry (acquire write lock): push new WorkspaceEntry
   - Save registry to disk via `filesystem::save_registry()`
   - Return the UUID string

6. `pub async fn list_workspaces(&self) -> Vec<WorkspaceEntry>`:
   - Acquire read lock on registry
   - Clone and return the workspaces vec

7. `pub async fn active_workspace_id(&self) -> Option<String>`:
   - Acquire read lock on active_workspace_id
   - Clone and return

8. `pub fn workspaces_root(&self) -> &Path`:
   - Return reference to workspaces_root PathBuf

9. `pub async fn close_active_workspace(&self) -> Result<(), String>`:
   - If there's an active DB, checkpoint WAL and close pool via cleanup()
   - Set active_db to None, active_workspace_id to None
   - For use during app shutdown

**Important implementation notes:**
- Use `SqliteConnectOptions::from_str()` with `create_if_missing(true)` and `.journal_mode(SqliteJournalMode::Wal)` and `.foreign_keys(true)` -- these are from `sqlx::sqlite::SqliteConnectOptions`
- Use `SqlitePoolOptions::new().max_connections(5).connect_with(options)` for pool creation
- The existing `DatabaseManager` has a `from_pool` pattern: Check if it exists. If not, the simplest approach is to make DatabaseManager::new accept a pool directly. BUT do not modify DatabaseManager in this plan -- instead, create the pool directly and store it, or create a `DatabaseManager` wrapper. The cleanest path: add a `pub fn from_pool(pool: SqlitePool) -> Self` constructor to DatabaseManager. This is a one-line addition that doesn't break anything. Add it to `database/manager.rs`.

Update `workspace/mod.rs` to add `pub mod manager;`.
  </action>
  <verify>
1. `cargo check --manifest-path frontend/src-tauri/Cargo.toml` passes with zero errors.
2. Verify WorkspaceManager struct exists with all 9 methods.
3. Verify `DatabaseManager::from_pool()` constructor was added.
  </verify>
  <done>
WorkspaceManager compiles with: init(), active_pool(), global_pool(), switch_workspace(), create_workspace(), list_workspaces(), active_workspace_id(), workspaces_root(), close_active_workspace(). DatabaseManager has a `from_pool()` constructor. The workspace module is fully self-contained and ready for integration.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path frontend/src-tauri/Cargo.toml` passes
2. WorkspaceManager is importable from `crate::workspace::manager::WorkspaceManager`
3. The struct uses `Arc<RwLock<...>>` for async-safe pool swapping
4. Global pool is always available (no Option wrapper)
5. Switch workspace: closes old pool (with WAL checkpoint), opens new pool, runs migrations
</verification>

<success_criteria>
- WorkspaceManager compiles and exports all required methods
- Pool lifecycle is correct: init opens global, switch_workspace swaps active, close_active_workspace cleans up
- Registry is updated on create/switch operations
- Only one workspace pool is ever open at a time
- No new crate dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-workspace-filesystem-db-isolation/01-02-SUMMARY.md`
</output>
