---
phase: 01-workspace-filesystem-db-isolation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src-tauri/src/workspace/mod.rs
  - frontend/src-tauri/src/workspace/types.rs
  - frontend/src-tauri/src/workspace/filesystem.rs
  - frontend/src-tauri/migrations/workspace/20260201000000_workspace_schema.sql
  - frontend/src-tauri/migrations/global/20260201000000_global_schema.sql
autonomous: true

must_haves:
  truths:
    - "A workspace folder created on disk contains manifest.json, config.json, audio/, and notes/ subdirectories"
    - "A corrupted or missing workspaces.json can be rebuilt by scanning workspace directories on disk"
    - "A fresh workspace database has tables for meetings, transcripts, summary_processes, transcript_chunks, and meeting_notes"
    - "A fresh global database has tables for settings, transcript_settings, licensing, and custom_openai_config"
    - "The application compiles with the new workspace module without breaking existing functionality"
  artifacts:
    - path: "frontend/src-tauri/src/workspace/types.rs"
      provides: "WorkspaceManifest, WorkspaceRegistry, WorkspaceEntry structs"
      contains: "WorkspaceManifest"
    - path: "frontend/src-tauri/src/workspace/filesystem.rs"
      provides: "create_workspace_dir, read_manifest, save_registry, rebuild_registry"
      contains: "create_workspace_dir"
    - path: "frontend/src-tauri/migrations/workspace/20260201000000_workspace_schema.sql"
      provides: "meetings, transcripts, summary_processes, transcript_chunks, meeting_notes tables"
      contains: "CREATE TABLE"
    - path: "frontend/src-tauri/migrations/global/20260201000000_global_schema.sql"
      provides: "settings, transcript_settings, licensing tables"
      contains: "CREATE TABLE"
  key_links:
    - from: "frontend/src-tauri/src/workspace/filesystem.rs"
      to: "frontend/src-tauri/src/workspace/types.rs"
      via: "uses WorkspaceManifest, WorkspaceRegistry, WorkspaceEntry structs"
      pattern: "use (super|crate)::.*types::"
---

<objective>
Create the workspace foundation layer: type definitions, filesystem operations, and split migration SQL sets.

Purpose: This is the bedrock that every other plan in Phase 1 depends on. Without typed structs for manifests/registry and filesystem helpers, the WorkspaceManager (Plan 02) cannot be built. Without split migration SQL, workspace and global databases cannot be initialized independently.

Output: Three Rust source files (workspace module with types and filesystem ops) and two migration SQL directories (workspace/ and global/) with initial schema.
</objective>

<execution_context>
@/Users/chaysenrathert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chaysenrathert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-CONTEXT.md
@.planning/phases/01-workspace-filesystem-db-isolation/01-RESEARCH.md

# Key existing files to understand current patterns
@frontend/src-tauri/src/lib.rs
@frontend/src-tauri/src/state.rs
@frontend/src-tauri/src/database/manager.rs
@frontend/src-tauri/migrations/20250916100000_initial_schema.sql
@frontend/src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace module with type definitions</name>
  <files>
    frontend/src-tauri/src/workspace/mod.rs
    frontend/src-tauri/src/workspace/types.rs
  </files>
  <action>
Create a new `workspace` module at `frontend/src-tauri/src/workspace/`.

In `mod.rs`, declare submodules: `pub mod types;` and `pub mod filesystem;` (filesystem will be created in Task 2).

In `types.rs`, define the following structs with `#[derive(Debug, Clone, Serialize, Deserialize)]`:

1. **WorkspaceManifest** -- per-workspace metadata stored in `manifest.json`:
   - `version: u32` (schema version, start at 1)
   - `name: String` (human-readable display name)
   - `icon: Option<String>` (optional emoji icon, e.g., a building emoji)
   - `accent_color: Option<String>` (hex color string, e.g., "#3B82F6")
   - `description: Option<String>` (user description of workspace purpose)
   - `app_version: Option<String>` (Meetily version that created this workspace -- debugging aid)
   - `created_at: String` (ISO 8601 timestamp)
   - `last_modified: String` (ISO 8601 timestamp, updated on any metadata change)

2. **WorkspaceEntry** -- cached entry in global registry for fast sidebar rendering:
   - `id: String` (UUID string matching folder name)
   - `name: String` (cached from manifest)
   - `icon: Option<String>` (cached from manifest)

3. **WorkspaceRegistry** -- global lookup file (`workspaces.json`):
   - `version: u32` (schema version, start at 1)
   - `workspaces: Vec<WorkspaceEntry>` (ordered list, order = sidebar order)
   - `last_active: Option<String>` (UUID of last active workspace for restore on launch)

Also add `pub mod workspace;` to `frontend/src-tauri/src/lib.rs` in the module declarations section (near the other `pub mod` statements).

Use existing crate dependencies only: `serde`, `serde_json`, `uuid`, `chrono`. Do NOT add new crates to Cargo.toml.
  </action>
  <verify>
Run `cargo check --manifest-path frontend/src-tauri/Cargo.toml` and confirm zero compilation errors. Verify the workspace module is recognized and types compile.
  </verify>
  <done>
WorkspaceManifest, WorkspaceEntry, and WorkspaceRegistry structs exist, compile, and are exported from the workspace module. lib.rs declares `pub mod workspace;`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create filesystem operations and split migration SQL</name>
  <files>
    frontend/src-tauri/src/workspace/filesystem.rs
    frontend/src-tauri/migrations/workspace/20260201000000_workspace_schema.sql
    frontend/src-tauri/migrations/global/20260201000000_global_schema.sql
  </files>
  <action>
**Part A: Filesystem operations (`workspace/filesystem.rs`)**

Create filesystem helper functions that operate on workspace directories. These are pure filesystem operations with no database pool access:

1. `pub fn create_workspace_dir(workspaces_root: &Path, workspace_id: &str) -> Result<PathBuf, String>`:
   - Creates directory `{workspaces_root}/{workspace_id}/`
   - Creates subdirectories: `audio/`, `notes/`
   - Returns the workspace directory path
   - Uses `std::fs::create_dir_all()` for safety

2. `pub fn write_manifest(workspace_dir: &Path, manifest: &WorkspaceManifest) -> Result<(), String>`:
   - Serializes manifest to pretty JSON via `serde_json::to_string_pretty()`
   - Writes to `{workspace_dir}/manifest.json`

3. `pub fn read_manifest(workspace_dir: &Path) -> Result<WorkspaceManifest, String>`:
   - Reads `{workspace_dir}/manifest.json`
   - Deserializes via `serde_json::from_str()`

4. `pub fn write_default_config(workspace_dir: &Path) -> Result<(), String>`:
   - Writes an empty JSON object `{}` to `{workspace_dir}/config.json`

5. `pub fn save_registry(workspaces_root: &Path, registry: &WorkspaceRegistry) -> Result<(), String>`:
   - Writes to `{workspaces_root}/workspaces.json.tmp` first (atomic write pattern)
   - Renames `.tmp` to `workspaces.json` via `std::fs::rename()`

6. `pub fn load_registry(workspaces_root: &Path) -> Result<WorkspaceRegistry, String>`:
   - Reads `{workspaces_root}/workspaces.json`
   - Returns default empty registry if file doesn't exist

7. `pub fn rebuild_registry_from_disk(workspaces_root: &Path) -> Result<WorkspaceRegistry, String>`:
   - Scans `workspaces_root` for directories containing `manifest.json`
   - Validates folder name is parseable as UUID (use `uuid::Uuid::parse_str()`)
   - Reads each manifest and builds a WorkspaceEntry
   - Returns a fresh WorkspaceRegistry with version 1 and `last_active: None`

Import types from `super::types`. Use `log::info!` and `log::warn!` for operation logging. All error types should be `String` for Tauri command compatibility.

**Part B: Split migration SQL sets**

Create two new migration directories with initial schema SQL. These are fresh migration sets for the split database architecture.

**`migrations/workspace/20260201000000_workspace_schema.sql`** -- Tables for per-workspace data:
- Copy the `meetings`, `transcripts`, `summary_processes`, `transcript_chunks` table definitions from the existing `20250916100000_initial_schema.sql`
- Also include the `meeting_notes` table from `20251223000000_add_meeting_notes.sql` (read that migration to get the exact schema)
- Include the `audio_sync_fields` additions from `20251006000000_add_audio_sync_fields.sql` (add those columns to the meetings CREATE TABLE -- read the migration for exact columns)
- Include the `speaker` field addition from `20251110000001_add_speaker_field.sql` (add to transcripts CREATE TABLE)
- Include the `summary_backup` field from `20251101000000_add_summary_backup.sql` (read migration for exact column)
- This should be a SINGLE consolidated CREATE TABLE set (not incremental migrations) since these are fresh databases
- Use `CREATE TABLE IF NOT EXISTS` for safety

**`migrations/global/20260201000000_global_schema.sql`** -- Tables for global data:
- Copy the `settings` table from `20250916100000_initial_schema.sql`
- Copy the `transcript_settings` table from the same migration
- Include the `openrouter_api_key` column from `20250920155811_add_openrouter_api_key.sql` in the settings CREATE TABLE
- Include the `ollama_endpoint` column from `20251010153942_add_ollama_endpoint.sql` in the settings CREATE TABLE
- Include the `licensing` and `custom_openai_config` tables from `20251105120000_add_pro_license_custom_openai.sql`
- Include the `grace_period` fields from `20251110000000_add_grace_period_to_licensing.sql` in the licensing CREATE TABLE
- Include the `gemini_api_key` column from `20251229000000_add_gemini_api_key.sql` in the settings CREATE TABLE
- This should be a SINGLE consolidated CREATE TABLE set
- Use `CREATE TABLE IF NOT EXISTS` for safety

Read EACH existing migration file before writing the consolidated versions to ensure no columns or tables are missed.
  </action>
  <verify>
1. Run `cargo check --manifest-path frontend/src-tauri/Cargo.toml` to confirm filesystem.rs compiles.
2. Verify both migration SQL files exist and contain valid SQL: `cat frontend/src-tauri/migrations/workspace/20260201000000_workspace_schema.sql` and `cat frontend/src-tauri/migrations/global/20260201000000_global_schema.sql`.
3. Verify the workspace migration has: meetings, transcripts, summary_processes, transcript_chunks, meeting_notes tables.
4. Verify the global migration has: settings, transcript_settings, licensing, custom_openai_config tables.
  </verify>
  <done>
Filesystem operations module exists with all 7 functions. Two migration SQL directories exist with consolidated schemas covering all columns from the 10 existing incremental migrations, correctly split between workspace-scoped and global-scoped tables.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path frontend/src-tauri/Cargo.toml` passes with zero errors
2. `frontend/src-tauri/src/workspace/` directory exists with mod.rs, types.rs, filesystem.rs
3. `frontend/src-tauri/migrations/workspace/` and `frontend/src-tauri/migrations/global/` directories exist with SQL files
4. `lib.rs` declares `pub mod workspace;`
5. All workspace types are exported and usable from `crate::workspace::types::`
</verification>

<success_criteria>
- Types (WorkspaceManifest, WorkspaceEntry, WorkspaceRegistry) compile and are importable
- Filesystem operations (create dir, manifest I/O, registry I/O, rebuild) compile
- Migration SQL sets are correctly split: workspace tables (meetings, transcripts, summaries, chunks, notes) vs global tables (settings, transcript_settings, licensing, custom_openai_config)
- No new crate dependencies added
- Existing codebase continues to compile (no breaking changes)
</success_criteria>

<output>
After completion, create `.planning/phases/01-workspace-filesystem-db-isolation/01-01-SUMMARY.md`
</output>
